import{r as $,F as W,B as J,t as V,u as K,H as F,v as C,w as S,L as X,x as j,M as Q,P as Z,C as z,a as ee,V as P,b as q,W as te,S as re,U as ne,N as oe,c as Y}from"./OrbitControls-DsYs44LZ.js";const N=new WeakMap;class ie extends ${constructor(e){super(e),this.decoderPath="",this.decoderConfig={},this.decoderBinary=null,this.decoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.defaultAttributeIDs={position:"POSITION",normal:"NORMAL",color:"COLOR",uv:"TEX_COORD"},this.defaultAttributeTypes={position:"Float32Array",normal:"Float32Array",color:"Float32Array",uv:"Float32Array"}}setDecoderPath(e){return this.decoderPath=e,this}setDecoderConfig(e){return this.decoderConfig=e,this}setWorkerLimit(e){return this.workerLimit=e,this}load(e,s,d,l){const h=new W(this.manager);h.setPath(this.path),h.setResponseType("arraybuffer"),h.setRequestHeader(this.requestHeader),h.setWithCredentials(this.withCredentials),h.load(e,t=>{this.decodeDracoFile(t,s).catch(l)},d,l)}decodeDracoFile(e,s,d,l){const h={attributeIDs:d||this.defaultAttributeIDs,attributeTypes:l||this.defaultAttributeTypes,useUniqueIDs:!!d};return this.decodeGeometry(e,h).then(s)}decodeGeometry(e,s){const d=JSON.stringify(s);if(N.has(e)){const y=N.get(e);if(y.key===d)return y.promise;if(e.byteLength===0)throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")}let l;const h=this.workerNextTaskID++,t=e.byteLength,a=this._getWorker(h,t).then(y=>(l=y,new Promise((A,b)=>{l._callbacks[h]={resolve:A,reject:b},l.postMessage({type:"decode",id:h,taskConfig:s,buffer:e},[e])}))).then(y=>this._createGeometry(y.geometry));return a.catch(()=>!0).then(()=>{l&&h&&this._releaseTask(l,h)}),N.set(e,{key:d,promise:a}),a}_createGeometry(e){const s=new J;e.index&&s.setIndex(new V(e.index.array,1));for(let d=0;d<e.attributes.length;d++){const l=e.attributes[d],h=l.name,t=l.array,a=l.itemSize;s.setAttribute(h,new V(t,a))}return s}_loadLibrary(e,s){const d=new W(this.manager);return d.setPath(this.decoderPath),d.setResponseType(s),d.setWithCredentials(this.withCredentials),new Promise((l,h)=>{d.load(e,l,void 0,h)})}preload(){return this._initDecoder(),this}_initDecoder(){if(this.decoderPending)return this.decoderPending;const e=typeof WebAssembly!="object"||this.decoderConfig.type==="js",s=[];return e?s.push(this._loadLibrary("draco_decoder.js","text")):(s.push(this._loadLibrary("draco_wasm_wrapper.js","text")),s.push(this._loadLibrary("draco_decoder.wasm","arraybuffer"))),this.decoderPending=Promise.all(s).then(d=>{const l=d[0];e||(this.decoderConfig.wasmBinary=d[1]);const h=ae.toString(),t=["/* draco decoder */",l,"","/* worker */",h.substring(h.indexOf("{")+1,h.lastIndexOf("}"))].join(`
`);this.workerSourceURL=URL.createObjectURL(new Blob([t]))}),this.decoderPending}_getWorker(e,s){return this._initDecoder().then(()=>{if(this.workerPool.length<this.workerLimit){const l=new Worker(this.workerSourceURL);l._callbacks={},l._taskCosts={},l._taskLoad=0,l.postMessage({type:"init",decoderConfig:this.decoderConfig}),l.onmessage=function(h){const t=h.data;switch(t.type){case"decode":l._callbacks[t.id].resolve(t);break;case"error":l._callbacks[t.id].reject(t);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+t.type+'"')}},this.workerPool.push(l)}else this.workerPool.sort(function(l,h){return l._taskLoad>h._taskLoad?-1:1});const d=this.workerPool[this.workerPool.length-1];return d._taskCosts[e]=s,d._taskLoad+=s,d})}_releaseTask(e,s){e._taskLoad-=e._taskCosts[s],delete e._callbacks[s],delete e._taskCosts[s]}debug(){console.log("Task load: ",this.workerPool.map(e=>e._taskLoad))}dispose(){for(let e=0;e<this.workerPool.length;++e)this.workerPool[e].terminate();return this.workerPool.length=0,this}}function ae(){let U,e;onmessage=function(t){const a=t.data;switch(a.type){case"init":U=a.decoderConfig,e=new Promise(function(b){U.onModuleLoaded=function(_){b({draco:_})},DracoDecoderModule(U)});break;case"decode":const y=a.buffer,A=a.taskConfig;e.then(b=>{const _=b.draco,m=new _.Decoder,E=new _.DecoderBuffer;E.Init(new Int8Array(y),y.byteLength);try{const w=s(_,m,E,A),T=w.attributes.map(R=>R.array.buffer);w.index&&T.push(w.index.array.buffer),self.postMessage({type:"decode",id:a.id,geometry:w},T)}catch(w){console.error(w),self.postMessage({type:"error",id:a.id,error:w.message})}finally{_.destroy(E),_.destroy(m)}});break}};function s(t,a,y,A){const b=A.attributeIDs,_=A.attributeTypes;let m,E;const w=a.GetEncodedGeometryType(y);if(w===t.TRIANGULAR_MESH)m=new t.Mesh,E=a.DecodeBufferToMesh(y,m);else if(w===t.POINT_CLOUD)m=new t.PointCloud,E=a.DecodeBufferToPointCloud(y,m);else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");if(!E.ok()||m.ptr===0)throw new Error("THREE.DRACOLoader: Decoding failed: "+E.error_msg());const T={index:null,attributes:[]};for(const R in b){const k=self[_[R]];let x,r;if(A.useUniqueIDs)r=b[R],x=a.GetAttributeByUniqueId(m,r);else{if(r=a.GetAttributeId(m,t[b[R]]),r===-1)continue;x=a.GetAttribute(m,r)}T.attributes.push(l(t,a,m,R,k,x))}return w===t.TRIANGULAR_MESH&&(T.index=d(t,a,m)),t.destroy(m),T}function d(t,a,y){const b=y.num_faces()*3,_=b*4,m=t._malloc(_);a.GetTrianglesUInt32Array(y,_,m);const E=new Uint32Array(t.HEAPF32.buffer,m,b).slice();return t._free(m),{array:E,itemSize:1}}function l(t,a,y,A,b,_){const m=_.num_components(),w=y.num_points()*m,T=w*b.BYTES_PER_ELEMENT,R=h(t,b),k=t._malloc(T);a.GetAttributeDataArrayForAllPoints(y,_,R,T,k);const x=new b(t.HEAPF32.buffer,k,w).slice();return t._free(k),{name:A,array:x,itemSize:m}}function h(t,a){switch(a){case Float32Array:return t.DT_FLOAT32;case Int8Array:return t.DT_INT8;case Int16Array:return t.DT_INT16;case Int32Array:return t.DT_INT32;case Uint8Array:return t.DT_UINT8;case Uint16Array:return t.DT_UINT16;case Uint32Array:return t.DT_UINT32}}}class le extends K{constructor(e){super(e),this.type=F}parse(e){const a=function(r,u){switch(r){case 1:console.error("THREE.RGBELoader Read Error: "+(u||""));break;case 2:console.error("THREE.RGBELoader Write Error: "+(u||""));break;case 3:console.error("THREE.RGBELoader Bad File Format: "+(u||""));break;default:case 4:console.error("THREE.RGBELoader: Error: "+(u||""))}return-1},_=`
`,m=function(r,u,c){u=u||1024;let g=r.pos,n=-1,i=0,f="",o=String.fromCharCode.apply(null,new Uint16Array(r.subarray(g,g+128)));for(;0>(n=o.indexOf(_))&&i<u&&g<r.byteLength;)f+=o,i+=o.length,g+=128,o+=String.fromCharCode.apply(null,new Uint16Array(r.subarray(g,g+128)));return-1<n?(c!==!1&&(r.pos+=i+n+1),f+o.slice(0,n)):!1},E=function(r){const u=/^#\?(\S+)/,c=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,p=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,g=/^\s*FORMAT=(\S+)\s*$/,n=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,i={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let f,o;if(r.pos>=r.byteLength||!(f=m(r)))return a(1,"no header found");if(!(o=f.match(u)))return a(3,"bad initial token");for(i.valid|=1,i.programtype=o[1],i.string+=f+`
`;f=m(r),f!==!1;){if(i.string+=f+`
`,f.charAt(0)==="#"){i.comments+=f+`
`;continue}if((o=f.match(c))&&(i.gamma=parseFloat(o[1])),(o=f.match(p))&&(i.exposure=parseFloat(o[1])),(o=f.match(g))&&(i.valid|=2,i.format=o[1]),(o=f.match(n))&&(i.valid|=4,i.height=parseInt(o[1],10),i.width=parseInt(o[2],10)),i.valid&2&&i.valid&4)break}return i.valid&2?i.valid&4?i:a(3,"missing image size specifier"):a(3,"missing format specifier")},w=function(r,u,c){const p=u;if(p<8||p>32767||r[0]!==2||r[1]!==2||r[2]&128)return new Uint8Array(r);if(p!==(r[2]<<8|r[3]))return a(3,"wrong scanline width");const g=new Uint8Array(4*u*c);if(!g.length)return a(4,"unable to allocate buffer space");let n=0,i=0;const f=4*p,o=new Uint8Array(4),D=new Uint8Array(f);let G=c;for(;G>0&&i<r.byteLength;){if(i+4>r.byteLength)return a(1);if(o[0]=r[i++],o[1]=r[i++],o[2]=r[i++],o[3]=r[i++],o[0]!=2||o[1]!=2||(o[2]<<8|o[3])!=p)return a(3,"bad rgbe scanline format");let I=0,M;for(;I<f&&i<r.byteLength;){M=r[i++];const L=M>128;if(L&&(M-=128),M===0||I+M>f)return a(3,"bad scanline data");if(L){const v=r[i++];for(let H=0;H<M;H++)D[I++]=v}else D.set(r.subarray(i,i+M),I),I+=M,i+=M}const B=p;for(let L=0;L<B;L++){let v=0;g[n]=D[L+v],v+=p,g[n+1]=D[L+v],v+=p,g[n+2]=D[L+v],v+=p,g[n+3]=D[L+v],n+=4}G--}return g},T=function(r,u,c,p){const g=r[u+3],n=Math.pow(2,g-128)/255;c[p+0]=r[u+0]*n,c[p+1]=r[u+1]*n,c[p+2]=r[u+2]*n,c[p+3]=1},R=function(r,u,c,p){const g=r[u+3],n=Math.pow(2,g-128)/255;c[p+0]=S.toHalfFloat(Math.min(r[u+0]*n,65504)),c[p+1]=S.toHalfFloat(Math.min(r[u+1]*n,65504)),c[p+2]=S.toHalfFloat(Math.min(r[u+2]*n,65504)),c[p+3]=S.toHalfFloat(1)},k=new Uint8Array(e);k.pos=0;const x=E(k);if(x!==-1){const r=x.width,u=x.height,c=w(k.subarray(k.pos),r,u);if(c!==-1){let p,g,n;switch(this.type){case C:n=c.length/4;const i=new Float32Array(n*4);for(let o=0;o<n;o++)T(c,o*4,i,o*4);p=i,g=C;break;case F:n=c.length/4;const f=new Uint16Array(n*4);for(let o=0;o<n;o++)R(c,o*4,f,o*4);p=f,g=F;break;default:console.error("THREE.RGBELoader: unsupported type: ",this.type);break}return{width:r,height:u,data:p,header:x.string,gamma:x.gamma,exposure:x.exposure,type:g}}}return null}setDataType(e){return this.type=e,this}load(e,s,d,l){function h(t,a){switch(t.type){case C:case F:t.encoding=X,t.minFilter=j,t.magFilter=j,t.generateMipmaps=!1,t.flipY=!0;break}s&&s(t,a)}return super.load(e,h,d,l)}}class O extends Q{constructor(e,s={}){super(e),this.isReflector=!0,this.type="Reflector",this.camera=new Z;const d=this,l=s.color!==void 0?new z(s.color):new z(8355711),h=s.textureWidth||512,t=s.textureHeight||512,a=s.clipBias||0,y=s.shader||O.ReflectorShader,A=s.multisample!==void 0?s.multisample:4,b=new ee,_=new P,m=new P,E=new P,w=new q,T=new P(0,0,-1),R=new Y,k=new P,x=new P,r=new Y,u=new q,c=this.camera,p=new te(h,t,{samples:A,type:F}),g=new re({uniforms:ne.clone(y.uniforms),fragmentShader:y.fragmentShader,vertexShader:y.vertexShader});g.uniforms.tDiffuse.value=p.texture,g.uniforms.color.value=l,g.uniforms.textureMatrix.value=u,this.material=g,this.onBeforeRender=function(n,i,f){if(m.setFromMatrixPosition(d.matrixWorld),E.setFromMatrixPosition(f.matrixWorld),w.extractRotation(d.matrixWorld),_.set(0,0,1),_.applyMatrix4(w),k.subVectors(m,E),k.dot(_)>0)return;k.reflect(_).negate(),k.add(m),w.extractRotation(f.matrixWorld),T.set(0,0,-1),T.applyMatrix4(w),T.add(E),x.subVectors(m,T),x.reflect(_).negate(),x.add(m),c.position.copy(k),c.up.set(0,1,0),c.up.applyMatrix4(w),c.up.reflect(_),c.lookAt(x),c.far=f.far,c.updateMatrixWorld(),c.projectionMatrix.copy(f.projectionMatrix),u.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),u.multiply(c.projectionMatrix),u.multiply(c.matrixWorldInverse),u.multiply(d.matrixWorld),b.setFromNormalAndCoplanarPoint(_,m),b.applyMatrix4(c.matrixWorldInverse),R.set(b.normal.x,b.normal.y,b.normal.z,b.constant);const o=c.projectionMatrix;r.x=(Math.sign(R.x)+o.elements[8])/o.elements[0],r.y=(Math.sign(R.y)+o.elements[9])/o.elements[5],r.z=-1,r.w=(1+o.elements[10])/o.elements[14],R.multiplyScalar(2/R.dot(r)),o.elements[2]=R.x,o.elements[6]=R.y,o.elements[10]=R.z+1-a,o.elements[14]=R.w,d.visible=!1;const D=n.getRenderTarget(),G=n.xr.enabled,I=n.shadowMap.autoUpdate,M=n.outputEncoding,B=n.toneMapping;n.xr.enabled=!1,n.shadowMap.autoUpdate=!1,n.outputEncoding=X,n.toneMapping=oe,n.setRenderTarget(p),n.state.buffers.depth.setMask(!0),n.autoClear===!1&&n.clear(),n.render(i,c),n.xr.enabled=G,n.shadowMap.autoUpdate=I,n.outputEncoding=M,n.toneMapping=B,n.setRenderTarget(D);const L=f.viewport;L!==void 0&&n.state.viewport(L),d.visible=!0},this.getRenderTarget=function(){return p},this.dispose=function(){p.dispose(),d.material.dispose()}}}O.ReflectorShader={uniforms:{color:{value:null},tDiffuse:{value:null},textureMatrix:{value:null}},vertexShader:`
		uniform mat4 textureMatrix;
		varying vec4 vUv;

		#include <common>
		#include <logdepthbuf_pars_vertex>

		void main() {

			vUv = textureMatrix * vec4( position, 1.0 );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			#include <logdepthbuf_vertex>

		}`,fragmentShader:`
		uniform vec3 color;
		uniform sampler2D tDiffuse;
		varying vec4 vUv;

		#include <logdepthbuf_pars_fragment>

		float blendOverlay( float base, float blend ) {

			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );

		}

		vec3 blendOverlay( vec3 base, vec3 blend ) {

			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );

		}

		void main() {

			#include <logdepthbuf_fragment>

			vec4 base = texture2DProj( tDiffuse, vUv );
			gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );

			#include <tonemapping_fragment>
			#include <encodings_fragment>

		}`};export{ie as D,O as R,le as a};
